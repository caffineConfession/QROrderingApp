datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Product {
  id            String        @id @default(cuid())
  name          String
  description   String?
  category      ItemCategory // COFFEE or SHAKES
  imageHint     String?       @default("food drink")
  isAvailable   Boolean       @default(true) // Is the base product available?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  menuItems     MenuItem[] // Coffee or Shake can have multiple serving types
  productRatings ProductRating[]
}

model MenuItem {
  id            String          @id @default(cuid())
  productId     String
  product       Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  servingType   ItemServingType // e.g., Cone, Cup
  price         Float
  stockQuantity Int             @default(0)
  isAvailable   Boolean         @default(true) // Is this specific serving type available?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  orderItems    OrderItem[]

  @@unique([productId, servingType]) // Ensure a product can't have duplicate serving types
  @@index([productId])
}

model Order {
  id                         String        @id @default(cuid())
  customerName               String?
  customerPhone              String?
  customerEmail              String?
  totalAmount                Float
  status                     OrderStatus   @default(PENDING_PREPARATION)
  paymentStatus              PaymentStatus @default(PENDING)
  paymentMethod              PaymentMethod
  orderSource                OrderSource   @default(CUSTOMER_ONLINE)
  createdAt                  DateTime      @default(now())
  updatedAt                  DateTime      @updatedAt
  items                      OrderItem[]
  takenById                  String? // AdminUser ID (email for now, to be CUID) who took/created manual order
  processedById              String? // AdminUser ID (email for now, to be CUID) who last updated status
  experienceRating           ExperienceRating?
  productRatings             ProductRating[]
  gatewayOrderId             String?       @unique // For Razorpay order_id
  gatewayPaymentId           String?       @unique // For Razorpay payment_id

  // Relations to AdminUser can be added later if using CUIDs for admin IDs
  // takenBy AdminUser? @relation("OrdersTaken", fields: [takenById], references: [id])
  // processedBy AdminUser? @relation("OrdersProcessed", fields: [processedById], references: [id])
}

model OrderItem {
  id              String          @id @default(cuid())
  orderId         String
  order           Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId       String          // Denormalized product ID from MenuItem's product
  productName     String          // Denormalized product name
  category        ItemCategory    // Denormalized category
  servingType     ItemServingType // Denormalized serving type
  quantity        Int
  priceAtPurchase Float           // Price per unit at the time of purchase
  customization   String?         // e.g., "sweet", "bitter" - consider making an enum if fixed values
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  menuItem   MenuItem? @relation(fields: [productId, servingType], references: [productId, servingType], onDelete: Restrict)
  // Constraint to ensure productId and servingType in OrderItem match an existing MenuItem
  // is not directly expressible in Prisma schema for non-id fields in this way.
  // This relation relies on the unique constraint in MenuItem and application logic.
  // If MenuItem is deleted, Restrict will prevent OrderItem deletion if it refers to it.

  @@index([orderId])
  @@index([productId, servingType])
}

model AdminUser {
  id           String     @id @default(cuid()) // Using email as ID for now for compatibility
  email        String     @unique
  passwordHash String
  role         AdminRole
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

model ExperienceRating {
  id        String   @id @default(cuid())
  orderId   String   @unique // Each order can have one overall experience rating
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  rating    Int // 1-5 stars
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductRating {
  id          String   @id @default(cuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId   String   // Corresponds to Product.id
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productName String   // Denormalized product name for easier display with rating
  rating      Int // 1-5 stars
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([orderId, productId]) // A user can rate a specific product in an order only once
  @@index([productId])
}


enum ItemCategory {
  COFFEE
  SHAKES
}

enum ItemServingType {
  Cone
  Cup
}

enum PaymentMethod {
  Cash
  UPI
  Razorpay
}

enum OrderStatus {
  AWAITING_PAYMENT_CONFIRMATION
  PENDING_PREPARATION
  PREPARING
  READY_FOR_PICKUP
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum OrderSource {
  CUSTOMER_ONLINE
  STAFF_MANUAL
}

enum AdminRole {
  MANUAL_ORDER_TAKER
  ORDER_PROCESSOR
  BUSINESS_MANAGER
}
