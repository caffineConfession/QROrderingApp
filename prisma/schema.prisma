
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model AdminUser {
  id              String        @id @default(cuid())
  email           String        @unique
  hashedPassword  String // In a real app, this would be a hash, not related to JWT_SECRET_KEY
  role            AdminRole
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  ordersProcessed Order[]       @relation("ProcessedOrders")
  ordersTaken     Order[]       @relation("TakenOrders")
  sessions        AdminSession[]
}

// Optional: For more robust session management if storing sessions in DB
model AdminSession {
  id        String     @id @default(cuid())
  sid       String     @unique // Session ID
  data      String     // Session data
  expiresAt DateTime
  adminUser AdminUser? @relation(fields: [adminUserId], references: [id])
  adminUserId String?
}

model Product {
  id          String       @id @default(cuid())
  name        String       // e.g., Vanilla, Chocolate Shake
  category    String       // e.g., Blended Cold Coffee, Shakes (matches MENU_CATEGORIES values)
  imageHint   String       // For placeholder images
  // Prices will be determined by category and serving type, possibly from constants or a related Price model later
  // basePrice   Float?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  orderItems  OrderItem[]
}

model Order {
  id              String      @id @default(cuid())
  customerName    String?     // Optional for quick orders, but good for manual entry
  customerPhone   String?
  customerEmail   String?     // Optional
  totalAmount     Float
  status          OrderStatus // e.g., PENDING, RECEIVED, PREPARING, COMPLETED, DELIVERED, CANCELLED
  paymentMethod   PaymentType // e.g., CASH, UPI, RAZORPAY_ONLINE
  paymentConfirmed Boolean    @default(false) // True if cash received or UPI confirmed
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  items           OrderItem[]

  processedBy   AdminUser?   @relation("ProcessedOrders", fields: [processedById], references: [id])
  processedById String?
  takenBy       AdminUser?   @relation("TakenOrders", fields: [takenById], references: [id]) // For manual orders
  takenById     String?
}

model OrderItem {
  id                String   @id @default(cuid())
  order             Order    @relation(fields: [orderId], references: [id])
  orderId           String
  product           Product  @relation(fields: [productId], references: [id])
  productId         String
  quantity          Int
  priceAtPurchase   Float    // Price per unit at the time of order (accounts for serving type)
  servingType       String   // e.g., "Cone", "Cup"
  customizationNotes String?  // e.g., "sweet", "bitter", "normal"
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

enum AdminRole {
  MANUAL_ORDER_TAKER
  ORDER_PROCESSOR
  BUSINESS_MANAGER
}

enum OrderStatus {
  PENDING_PAYMENT // For online orders before payment or cash orders before confirmation
  RECEIVED        // Payment confirmed, ready for processing
  PREPARING
  READY_FOR_PICKUP
  COMPLETED       // Picked up / Delivered
  CANCELLED
}

enum PaymentType {
  CASH
  UPI
  RAZORPAY_ONLINE // For customer-facing app's online payments
}
